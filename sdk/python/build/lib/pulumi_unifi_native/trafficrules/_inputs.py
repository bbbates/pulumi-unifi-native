# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'TrafficDomainDtoArgs',
    'TrafficDomainDtoArgsDict',
    'TrafficIpDtoArgs',
    'TrafficIpDtoArgsDict',
    'TrafficIpRangeDtoArgs',
    'TrafficIpRangeDtoArgsDict',
    'TrafficPortRangeDtoArgs',
    'TrafficPortRangeDtoArgsDict',
    'TrafficRuleBandwidthLimitDtoArgs',
    'TrafficRuleBandwidthLimitDtoArgsDict',
    'TrafficRuleScheduleDtoArgs',
    'TrafficRuleScheduleDtoArgsDict',
    'TrafficTargetDeviceDtoArgs',
    'TrafficTargetDeviceDtoArgsDict',
]

MYPY = False

if not MYPY:
    class TrafficDomainDtoArgsDict(TypedDict):
        domain: pulumi.Input[builtins.str]
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['TrafficPortRangeDtoArgsDict']]]]
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    TrafficDomainDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficDomainDtoArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[builtins.str],
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficPortRangeDtoArgs']]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        pulumi.set(__self__, "domain", domain)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrafficPortRangeDtoArgs']]]]:
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficPortRangeDtoArgs']]]]):
        pulumi.set(self, "port_ranges", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class TrafficIpDtoArgsDict(TypedDict):
        ip_or_subnet: pulumi.Input[builtins.str]
        ip_version: pulumi.Input['TrafficIpDtoIpVersion']
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['TrafficPortRangeDtoArgsDict']]]]
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
elif False:
    TrafficIpDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficIpDtoArgs:
    def __init__(__self__, *,
                 ip_or_subnet: pulumi.Input[builtins.str],
                 ip_version: pulumi.Input['TrafficIpDtoIpVersion'],
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficPortRangeDtoArgs']]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None):
        pulumi.set(__self__, "ip_or_subnet", ip_or_subnet)
        pulumi.set(__self__, "ip_version", ip_version)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="ipOrSubnet")
    def ip_or_subnet(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip_or_subnet")

    @ip_or_subnet.setter
    def ip_or_subnet(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip_or_subnet", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> pulumi.Input['TrafficIpDtoIpVersion']:
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: pulumi.Input['TrafficIpDtoIpVersion']):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrafficPortRangeDtoArgs']]]]:
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficPortRangeDtoArgs']]]]):
        pulumi.set(self, "port_ranges", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class TrafficIpRangeDtoArgsDict(TypedDict):
        ip_start: pulumi.Input[builtins.str]
        ip_stop: pulumi.Input[builtins.str]
        ip_version: pulumi.Input['TrafficIpRangeDtoIpVersion']
elif False:
    TrafficIpRangeDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficIpRangeDtoArgs:
    def __init__(__self__, *,
                 ip_start: pulumi.Input[builtins.str],
                 ip_stop: pulumi.Input[builtins.str],
                 ip_version: pulumi.Input['TrafficIpRangeDtoIpVersion']):
        pulumi.set(__self__, "ip_start", ip_start)
        pulumi.set(__self__, "ip_stop", ip_stop)
        pulumi.set(__self__, "ip_version", ip_version)

    @property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip_start")

    @ip_start.setter
    def ip_start(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip_start", value)

    @property
    @pulumi.getter(name="ipStop")
    def ip_stop(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip_stop")

    @ip_stop.setter
    def ip_stop(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip_stop", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> pulumi.Input['TrafficIpRangeDtoIpVersion']:
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: pulumi.Input['TrafficIpRangeDtoIpVersion']):
        pulumi.set(self, "ip_version", value)


if not MYPY:
    class TrafficPortRangeDtoArgsDict(TypedDict):
        port_start: NotRequired[pulumi.Input[builtins.int]]
        port_stop: NotRequired[pulumi.Input[builtins.int]]
elif False:
    TrafficPortRangeDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficPortRangeDtoArgs:
    def __init__(__self__, *,
                 port_start: Optional[pulumi.Input[builtins.int]] = None,
                 port_stop: Optional[pulumi.Input[builtins.int]] = None):
        if port_start is not None:
            pulumi.set(__self__, "port_start", port_start)
        if port_stop is not None:
            pulumi.set(__self__, "port_stop", port_stop)

    @property
    @pulumi.getter(name="portStart")
    def port_start(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port_start")

    @port_start.setter
    def port_start(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port_start", value)

    @property
    @pulumi.getter(name="portStop")
    def port_stop(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port_stop")

    @port_stop.setter
    def port_stop(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port_stop", value)


if not MYPY:
    class TrafficRuleBandwidthLimitDtoArgsDict(TypedDict):
        download_limit_kbps: NotRequired[pulumi.Input[builtins.int]]
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        upload_limit_kbps: NotRequired[pulumi.Input[builtins.int]]
elif False:
    TrafficRuleBandwidthLimitDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficRuleBandwidthLimitDtoArgs:
    def __init__(__self__, *,
                 download_limit_kbps: Optional[pulumi.Input[builtins.int]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 upload_limit_kbps: Optional[pulumi.Input[builtins.int]] = None):
        if download_limit_kbps is not None:
            pulumi.set(__self__, "download_limit_kbps", download_limit_kbps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if upload_limit_kbps is not None:
            pulumi.set(__self__, "upload_limit_kbps", upload_limit_kbps)

    @property
    @pulumi.getter(name="downloadLimitKbps")
    def download_limit_kbps(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "download_limit_kbps")

    @download_limit_kbps.setter
    def download_limit_kbps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "download_limit_kbps", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="uploadLimitKbps")
    def upload_limit_kbps(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "upload_limit_kbps")

    @upload_limit_kbps.setter
    def upload_limit_kbps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "upload_limit_kbps", value)


if not MYPY:
    class TrafficRuleScheduleDtoArgsDict(TypedDict):
        mode: pulumi.Input['TrafficRuleScheduleDtoMode']
        end_date_applicable_to_custom: NotRequired[pulumi.Input[builtins.str]]
        start_date_applicable_to_custom: NotRequired[pulumi.Input[builtins.str]]
        date: NotRequired[pulumi.Input[builtins.str]]
        """
        Start date. Applicable to: ONE_TIME_ONLY
        """
        repeat_on_days: NotRequired[pulumi.Input[Sequence[pulumi.Input['TrafficRuleScheduleDtoRepeatOnDaysItem']]]]
        """
        Repeat on on days. Applicable to: EVERY_WEEK, CUSTOM
        """
        time_all_day: NotRequired[pulumi.Input[builtins.bool]]
        """
        Rule will be running for all day. Time range start/end are ignored. Applicable to: EVERY_WEEK, CUSTOM
        """
        time_range_end: NotRequired[pulumi.Input[builtins.str]]
        """
        End time in 24 hours format. It accepts 24:00 as end of the day. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        time_range_start: NotRequired[pulumi.Input[builtins.str]]
        """
        Start time in 24 hours format. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
elif False:
    TrafficRuleScheduleDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficRuleScheduleDtoArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input['TrafficRuleScheduleDtoMode'],
                 end_date_applicable_to_custom: Optional[pulumi.Input[builtins.str]] = None,
                 start_date_applicable_to_custom: Optional[pulumi.Input[builtins.str]] = None,
                 date: Optional[pulumi.Input[builtins.str]] = None,
                 repeat_on_days: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficRuleScheduleDtoRepeatOnDaysItem']]]] = None,
                 time_all_day: Optional[pulumi.Input[builtins.bool]] = None,
                 time_range_end: Optional[pulumi.Input[builtins.str]] = None,
                 time_range_start: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] date: Start date. Applicable to: ONE_TIME_ONLY
        :param pulumi.Input[Sequence[pulumi.Input['TrafficRuleScheduleDtoRepeatOnDaysItem']]] repeat_on_days: Repeat on on days. Applicable to: EVERY_WEEK, CUSTOM
        :param pulumi.Input[builtins.bool] time_all_day: Rule will be running for all day. Time range start/end are ignored. Applicable to: EVERY_WEEK, CUSTOM
        :param pulumi.Input[builtins.str] time_range_end: End time in 24 hours format. It accepts 24:00 as end of the day. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        :param pulumi.Input[builtins.str] time_range_start: Start time in 24 hours format. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        pulumi.set(__self__, "mode", mode)
        if end_date_applicable_to_custom is not None:
            pulumi.set(__self__, "end_date_applicable_to_custom", end_date_applicable_to_custom)
        if start_date_applicable_to_custom is not None:
            pulumi.set(__self__, "start_date_applicable_to_custom", start_date_applicable_to_custom)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if repeat_on_days is not None:
            pulumi.set(__self__, "repeat_on_days", repeat_on_days)
        if time_all_day is not None:
            pulumi.set(__self__, "time_all_day", time_all_day)
        if time_range_end is not None:
            pulumi.set(__self__, "time_range_end", time_range_end)
        if time_range_start is not None:
            pulumi.set(__self__, "time_range_start", time_range_start)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input['TrafficRuleScheduleDtoMode']:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input['TrafficRuleScheduleDtoMode']):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="EndDateApplicableToCUSTOM")
    def end_date_applicable_to_custom(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "end_date_applicable_to_custom")

    @end_date_applicable_to_custom.setter
    def end_date_applicable_to_custom(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_date_applicable_to_custom", value)

    @property
    @pulumi.getter(name="StartDateApplicableToCUSTOM")
    def start_date_applicable_to_custom(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "start_date_applicable_to_custom")

    @start_date_applicable_to_custom.setter
    def start_date_applicable_to_custom(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_date_applicable_to_custom", value)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start date. Applicable to: ONE_TIME_ONLY
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter(name="repeatOnDays")
    def repeat_on_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrafficRuleScheduleDtoRepeatOnDaysItem']]]]:
        """
        Repeat on on days. Applicable to: EVERY_WEEK, CUSTOM
        """
        return pulumi.get(self, "repeat_on_days")

    @repeat_on_days.setter
    def repeat_on_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficRuleScheduleDtoRepeatOnDaysItem']]]]):
        pulumi.set(self, "repeat_on_days", value)

    @property
    @pulumi.getter(name="timeAllDay")
    def time_all_day(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Rule will be running for all day. Time range start/end are ignored. Applicable to: EVERY_WEEK, CUSTOM
        """
        return pulumi.get(self, "time_all_day")

    @time_all_day.setter
    def time_all_day(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "time_all_day", value)

    @property
    @pulumi.getter(name="timeRangeEnd")
    def time_range_end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End time in 24 hours format. It accepts 24:00 as end of the day. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        return pulumi.get(self, "time_range_end")

    @time_range_end.setter
    def time_range_end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_range_end", value)

    @property
    @pulumi.getter(name="timeRangeStart")
    def time_range_start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start time in 24 hours format. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        return pulumi.get(self, "time_range_start")

    @time_range_start.setter
    def time_range_start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_range_start", value)


if not MYPY:
    class TrafficTargetDeviceDtoArgsDict(TypedDict):
        type: pulumi.Input['TrafficTargetDeviceDtoType']
        client_mac: NotRequired[pulumi.Input[builtins.str]]
        network_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    TrafficTargetDeviceDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficTargetDeviceDtoArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['TrafficTargetDeviceDtoType'],
                 client_mac: Optional[pulumi.Input[builtins.str]] = None,
                 network_id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if client_mac is not None:
            pulumi.set(__self__, "client_mac", client_mac)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['TrafficTargetDeviceDtoType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['TrafficTargetDeviceDtoType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="clientMac")
    def client_mac(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_mac")

    @client_mac.setter
    def client_mac(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_mac", value)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network_id", value)


