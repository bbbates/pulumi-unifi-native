# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'TrafficDomainDto',
    'TrafficIpDto',
    'TrafficIpRangeDto',
    'TrafficPortRangeDto',
    'TrafficRuleBandwidthLimitDto',
    'TrafficRuleDto',
    'TrafficRuleScheduleDto',
    'TrafficTargetDeviceDto',
]

@pulumi.output_type
class TrafficDomainDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficDomainDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficDomainDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficDomainDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: builtins.str,
                 port_ranges: Optional[Sequence['outputs.TrafficPortRangeDto']] = None,
                 ports: Optional[Sequence[builtins.int]] = None):
        pulumi.set(__self__, "domain", domain)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def domain(self) -> builtins.str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.TrafficPortRangeDto']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "ports")


@pulumi.output_type
class TrafficIpDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipOrSubnet":
            suggest = "ip_or_subnet"
        elif key == "ipVersion":
            suggest = "ip_version"
        elif key == "portRanges":
            suggest = "port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficIpDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficIpDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficIpDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_or_subnet: builtins.str,
                 ip_version: 'TrafficIpDtoIpVersion',
                 port_ranges: Optional[Sequence['outputs.TrafficPortRangeDto']] = None,
                 ports: Optional[Sequence[builtins.int]] = None):
        pulumi.set(__self__, "ip_or_subnet", ip_or_subnet)
        pulumi.set(__self__, "ip_version", ip_version)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter(name="ipOrSubnet")
    def ip_or_subnet(self) -> builtins.str:
        return pulumi.get(self, "ip_or_subnet")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> 'TrafficIpDtoIpVersion':
        return pulumi.get(self, "ip_version")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.TrafficPortRangeDto']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "ports")


@pulumi.output_type
class TrafficIpRangeDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipStart":
            suggest = "ip_start"
        elif key == "ipStop":
            suggest = "ip_stop"
        elif key == "ipVersion":
            suggest = "ip_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficIpRangeDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficIpRangeDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficIpRangeDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_start: builtins.str,
                 ip_stop: builtins.str,
                 ip_version: 'TrafficIpRangeDtoIpVersion'):
        pulumi.set(__self__, "ip_start", ip_start)
        pulumi.set(__self__, "ip_stop", ip_stop)
        pulumi.set(__self__, "ip_version", ip_version)

    @property
    @pulumi.getter(name="ipStart")
    def ip_start(self) -> builtins.str:
        return pulumi.get(self, "ip_start")

    @property
    @pulumi.getter(name="ipStop")
    def ip_stop(self) -> builtins.str:
        return pulumi.get(self, "ip_stop")

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> 'TrafficIpRangeDtoIpVersion':
        return pulumi.get(self, "ip_version")


@pulumi.output_type
class TrafficPortRangeDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portStart":
            suggest = "port_start"
        elif key == "portStop":
            suggest = "port_stop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficPortRangeDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficPortRangeDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficPortRangeDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_start: Optional[builtins.int] = None,
                 port_stop: Optional[builtins.int] = None):
        if port_start is not None:
            pulumi.set(__self__, "port_start", port_start)
        if port_stop is not None:
            pulumi.set(__self__, "port_stop", port_stop)

    @property
    @pulumi.getter(name="portStart")
    def port_start(self) -> Optional[builtins.int]:
        return pulumi.get(self, "port_start")

    @property
    @pulumi.getter(name="portStop")
    def port_stop(self) -> Optional[builtins.int]:
        return pulumi.get(self, "port_stop")


@pulumi.output_type
class TrafficRuleBandwidthLimitDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "downloadLimitKbps":
            suggest = "download_limit_kbps"
        elif key == "uploadLimitKbps":
            suggest = "upload_limit_kbps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficRuleBandwidthLimitDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficRuleBandwidthLimitDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficRuleBandwidthLimitDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 download_limit_kbps: Optional[builtins.int] = None,
                 enabled: Optional[builtins.bool] = None,
                 upload_limit_kbps: Optional[builtins.int] = None):
        if download_limit_kbps is not None:
            pulumi.set(__self__, "download_limit_kbps", download_limit_kbps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if upload_limit_kbps is not None:
            pulumi.set(__self__, "upload_limit_kbps", upload_limit_kbps)

    @property
    @pulumi.getter(name="downloadLimitKbps")
    def download_limit_kbps(self) -> Optional[builtins.int]:
        return pulumi.get(self, "download_limit_kbps")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="uploadLimitKbps")
    def upload_limit_kbps(self) -> Optional[builtins.int]:
        return pulumi.get(self, "upload_limit_kbps")


@pulumi.output_type
class TrafficRuleDto(dict):
    def __init__(__self__, *,
                 action: 'TrafficRuleDtoAction',
                 matching_target: 'TrafficRuleDtoMatchingTarget',
                 target_devices: Sequence['outputs.TrafficTargetDeviceDto'],
                 id: Optional[builtins.str] = None,
                 traffic_direction_used_for_internet_and_local_network_targets: Optional['TrafficRuleDtoTrafficDirectionUsedForInternetAndLocalNetworkTargets'] = None,
                 app_category_ids: Optional[Sequence[builtins.int]] = None,
                 app_ids: Optional[Sequence[builtins.int]] = None,
                 bandwidth_limit: Optional['outputs.TrafficRuleBandwidthLimitDto'] = None,
                 description: Optional[builtins.str] = None,
                 domains: Optional[Sequence['outputs.TrafficDomainDto']] = None,
                 enabled: Optional[builtins.bool] = None,
                 ip_addresses: Optional[Sequence['outputs.TrafficIpDto']] = None,
                 ip_ranges: Optional[Sequence['outputs.TrafficIpRangeDto']] = None,
                 network_ids: Optional[Sequence[builtins.str]] = None,
                 regions: Optional[Sequence[builtins.str]] = None,
                 schedule: Optional['outputs.TrafficRuleScheduleDto'] = None):
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "matching_target", matching_target)
        pulumi.set(__self__, "target_devices", target_devices)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if traffic_direction_used_for_internet_and_local_network_targets is not None:
            pulumi.set(__self__, "traffic_direction_used_for_internet_and_local_network_targets", traffic_direction_used_for_internet_and_local_network_targets)
        if app_category_ids is not None:
            pulumi.set(__self__, "app_category_ids", app_category_ids)
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if bandwidth_limit is not None:
            pulumi.set(__self__, "bandwidth_limit", bandwidth_limit)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)
        if network_ids is not None:
            pulumi.set(__self__, "network_ids", network_ids)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def action(self) -> 'TrafficRuleDtoAction':
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="matchingTarget")
    def matching_target(self) -> 'TrafficRuleDtoMatchingTarget':
        return pulumi.get(self, "matching_target")

    @property
    @pulumi.getter(name="targetDevices")
    def target_devices(self) -> Sequence['outputs.TrafficTargetDeviceDto']:
        return pulumi.get(self, "target_devices")

    @property
    @pulumi.getter(name="Id")
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="TrafficDirectionUsedForInternetAndLocalNetworkTargets")
    def traffic_direction_used_for_internet_and_local_network_targets(self) -> Optional['TrafficRuleDtoTrafficDirectionUsedForInternetAndLocalNetworkTargets']:
        return pulumi.get(self, "traffic_direction_used_for_internet_and_local_network_targets")

    @property
    @pulumi.getter(name="appCategoryIds")
    def app_category_ids(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "app_category_ids")

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "app_ids")

    @property
    @pulumi.getter(name="bandwidthLimit")
    def bandwidth_limit(self) -> Optional['outputs.TrafficRuleBandwidthLimitDto']:
        return pulumi.get(self, "bandwidth_limit")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence['outputs.TrafficDomainDto']]:
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence['outputs.TrafficIpDto']]:
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence['outputs.TrafficIpRangeDto']]:
        return pulumi.get(self, "ip_ranges")

    @property
    @pulumi.getter(name="networkIds")
    def network_ids(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "network_ids")

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.TrafficRuleScheduleDto']:
        return pulumi.get(self, "schedule")


@pulumi.output_type
class TrafficRuleScheduleDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "EndDateApplicableToCUSTOM":
            suggest = "end_date_applicable_to_custom"
        elif key == "StartDateApplicableToCUSTOM":
            suggest = "start_date_applicable_to_custom"
        elif key == "repeatOnDays":
            suggest = "repeat_on_days"
        elif key == "timeAllDay":
            suggest = "time_all_day"
        elif key == "timeRangeEnd":
            suggest = "time_range_end"
        elif key == "timeRangeStart":
            suggest = "time_range_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficRuleScheduleDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficRuleScheduleDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficRuleScheduleDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: 'TrafficRuleScheduleDtoMode',
                 end_date_applicable_to_custom: Optional[builtins.str] = None,
                 start_date_applicable_to_custom: Optional[builtins.str] = None,
                 date: Optional[builtins.str] = None,
                 repeat_on_days: Optional[Sequence['TrafficRuleScheduleDtoRepeatOnDaysItem']] = None,
                 time_all_day: Optional[builtins.bool] = None,
                 time_range_end: Optional[builtins.str] = None,
                 time_range_start: Optional[builtins.str] = None):
        """
        :param builtins.str date: Start date. Applicable to: ONE_TIME_ONLY
        :param Sequence['TrafficRuleScheduleDtoRepeatOnDaysItem'] repeat_on_days: Repeat on on days. Applicable to: EVERY_WEEK, CUSTOM
        :param builtins.bool time_all_day: Rule will be running for all day. Time range start/end are ignored. Applicable to: EVERY_WEEK, CUSTOM
        :param builtins.str time_range_end: End time in 24 hours format. It accepts 24:00 as end of the day. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        :param builtins.str time_range_start: Start time in 24 hours format. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        pulumi.set(__self__, "mode", mode)
        if end_date_applicable_to_custom is not None:
            pulumi.set(__self__, "end_date_applicable_to_custom", end_date_applicable_to_custom)
        if start_date_applicable_to_custom is not None:
            pulumi.set(__self__, "start_date_applicable_to_custom", start_date_applicable_to_custom)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if repeat_on_days is not None:
            pulumi.set(__self__, "repeat_on_days", repeat_on_days)
        if time_all_day is not None:
            pulumi.set(__self__, "time_all_day", time_all_day)
        if time_range_end is not None:
            pulumi.set(__self__, "time_range_end", time_range_end)
        if time_range_start is not None:
            pulumi.set(__self__, "time_range_start", time_range_start)

    @property
    @pulumi.getter
    def mode(self) -> 'TrafficRuleScheduleDtoMode':
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="EndDateApplicableToCUSTOM")
    def end_date_applicable_to_custom(self) -> Optional[builtins.str]:
        return pulumi.get(self, "end_date_applicable_to_custom")

    @property
    @pulumi.getter(name="StartDateApplicableToCUSTOM")
    def start_date_applicable_to_custom(self) -> Optional[builtins.str]:
        return pulumi.get(self, "start_date_applicable_to_custom")

    @property
    @pulumi.getter
    def date(self) -> Optional[builtins.str]:
        """
        Start date. Applicable to: ONE_TIME_ONLY
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter(name="repeatOnDays")
    def repeat_on_days(self) -> Optional[Sequence['TrafficRuleScheduleDtoRepeatOnDaysItem']]:
        """
        Repeat on on days. Applicable to: EVERY_WEEK, CUSTOM
        """
        return pulumi.get(self, "repeat_on_days")

    @property
    @pulumi.getter(name="timeAllDay")
    def time_all_day(self) -> Optional[builtins.bool]:
        """
        Rule will be running for all day. Time range start/end are ignored. Applicable to: EVERY_WEEK, CUSTOM
        """
        return pulumi.get(self, "time_all_day")

    @property
    @pulumi.getter(name="timeRangeEnd")
    def time_range_end(self) -> Optional[builtins.str]:
        """
        End time in 24 hours format. It accepts 24:00 as end of the day. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        return pulumi.get(self, "time_range_end")

    @property
    @pulumi.getter(name="timeRangeStart")
    def time_range_start(self) -> Optional[builtins.str]:
        """
        Start time in 24 hours format. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        return pulumi.get(self, "time_range_start")


@pulumi.output_type
class TrafficTargetDeviceDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientMac":
            suggest = "client_mac"
        elif key == "networkId":
            suggest = "network_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficTargetDeviceDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficTargetDeviceDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficTargetDeviceDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'TrafficTargetDeviceDtoType',
                 client_mac: Optional[builtins.str] = None,
                 network_id: Optional[builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if client_mac is not None:
            pulumi.set(__self__, "client_mac", client_mac)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)

    @property
    @pulumi.getter
    def type(self) -> 'TrafficTargetDeviceDtoType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="clientMac")
    def client_mac(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_mac")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "network_id")


