# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'StackingLagDtoArgs',
    'StackingLagDtoArgsDict',
    'StackingLagGroupDtoArgs',
    'StackingLagGroupDtoArgsDict',
    'StackingLinkDtoArgs',
    'StackingLinkDtoArgsDict',
    'StackingUnitDtoArgs',
    'StackingUnitDtoArgsDict',
]

MYPY = False

if not MYPY:
    class StackingLagDtoArgsDict(TypedDict):
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        unit_index: NotRequired[pulumi.Input[builtins.int]]
elif False:
    StackingLagDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StackingLagDtoArgs:
    def __init__(__self__, *,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 unit_index: Optional[pulumi.Input[builtins.int]] = None):
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if unit_index is not None:
            pulumi.set(__self__, "unit_index", unit_index)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter(name="unitIndex")
    def unit_index(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "unit_index")

    @unit_index.setter
    def unit_index(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "unit_index", value)


if not MYPY:
    class StackingLagGroupDtoArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.int]]
        unit_lags: NotRequired[pulumi.Input[Sequence[pulumi.Input['StackingLagDtoArgsDict']]]]
elif False:
    StackingLagGroupDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StackingLagGroupDtoArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.int]] = None,
                 unit_lags: Optional[pulumi.Input[Sequence[pulumi.Input['StackingLagDtoArgs']]]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if unit_lags is not None:
            pulumi.set(__self__, "unit_lags", unit_lags)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="unitLags")
    def unit_lags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StackingLagDtoArgs']]]]:
        return pulumi.get(self, "unit_lags")

    @unit_lags.setter
    def unit_lags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StackingLagDtoArgs']]]]):
        pulumi.set(self, "unit_lags", value)


if not MYPY:
    class StackingLinkDtoArgsDict(TypedDict):
        left_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        left_unit_index: NotRequired[pulumi.Input[builtins.int]]
        right_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        right_unit_index: NotRequired[pulumi.Input[builtins.int]]
elif False:
    StackingLinkDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StackingLinkDtoArgs:
    def __init__(__self__, *,
                 left_ports: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 left_unit_index: Optional[pulumi.Input[builtins.int]] = None,
                 right_ports: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 right_unit_index: Optional[pulumi.Input[builtins.int]] = None):
        if left_ports is not None:
            pulumi.set(__self__, "left_ports", left_ports)
        if left_unit_index is not None:
            pulumi.set(__self__, "left_unit_index", left_unit_index)
        if right_ports is not None:
            pulumi.set(__self__, "right_ports", right_ports)
        if right_unit_index is not None:
            pulumi.set(__self__, "right_unit_index", right_unit_index)

    @property
    @pulumi.getter(name="leftPorts")
    def left_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "left_ports")

    @left_ports.setter
    def left_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "left_ports", value)

    @property
    @pulumi.getter(name="leftUnitIndex")
    def left_unit_index(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "left_unit_index")

    @left_unit_index.setter
    def left_unit_index(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "left_unit_index", value)

    @property
    @pulumi.getter(name="rightPorts")
    def right_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "right_ports")

    @right_ports.setter
    def right_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "right_ports", value)

    @property
    @pulumi.getter(name="rightUnitIndex")
    def right_unit_index(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "right_unit_index")

    @right_unit_index.setter
    def right_unit_index(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "right_unit_index", value)


if not MYPY:
    class StackingUnitDtoArgsDict(TypedDict):
        role: pulumi.Input['StackingUnitDtoRole']
        index: NotRequired[pulumi.Input[builtins.int]]
        mac: NotRequired[pulumi.Input[builtins.str]]
elif False:
    StackingUnitDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StackingUnitDtoArgs:
    def __init__(__self__, *,
                 role: pulumi.Input['StackingUnitDtoRole'],
                 index: Optional[pulumi.Input[builtins.int]] = None,
                 mac: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "role", role)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input['StackingUnitDtoRole']:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input['StackingUnitDtoRole']):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac", value)


