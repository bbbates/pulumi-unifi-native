# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'FirewallPolicyScheduleDtoArgs',
    'FirewallPolicyScheduleDtoArgsDict',
    'FirewallQosDestinationDtoArgs',
    'FirewallQosDestinationDtoArgsDict',
    'FirewallQosSourceDtoArgs',
    'FirewallQosSourceDtoArgsDict',
]

MYPY = False

if not MYPY:
    class FirewallPolicyScheduleDtoArgsDict(TypedDict):
        mode: pulumi.Input['FirewallPolicyScheduleDtoMode']
        end_date_applicable_to_custom: NotRequired[pulumi.Input[builtins.str]]
        start_date_applicable_to_custom: NotRequired[pulumi.Input[builtins.str]]
        date: NotRequired[pulumi.Input[builtins.str]]
        """
        Start date. Applicable to: ONE_TIME_ONLY
        """
        repeat_on_days: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyScheduleDtoRepeatOnDaysItem']]]]
        """
        Repeat on on days. Applicable to: EVERY_WEEK, CUSTOM
        """
        time_all_day: NotRequired[pulumi.Input[builtins.bool]]
        """
        Rule will be running for all day. Time range start/end are ignored. Applicable to: EVERY_WEEK, CUSTOM
        """
        time_range_end: NotRequired[pulumi.Input[builtins.str]]
        """
        End time in 24 hours format. It accepts 24:00 as end of the day. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        time_range_start: NotRequired[pulumi.Input[builtins.str]]
        """
        Start time in 24 hours format. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
elif False:
    FirewallPolicyScheduleDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyScheduleDtoArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input['FirewallPolicyScheduleDtoMode'],
                 end_date_applicable_to_custom: Optional[pulumi.Input[builtins.str]] = None,
                 start_date_applicable_to_custom: Optional[pulumi.Input[builtins.str]] = None,
                 date: Optional[pulumi.Input[builtins.str]] = None,
                 repeat_on_days: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyScheduleDtoRepeatOnDaysItem']]]] = None,
                 time_all_day: Optional[pulumi.Input[builtins.bool]] = None,
                 time_range_end: Optional[pulumi.Input[builtins.str]] = None,
                 time_range_start: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] date: Start date. Applicable to: ONE_TIME_ONLY
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyScheduleDtoRepeatOnDaysItem']]] repeat_on_days: Repeat on on days. Applicable to: EVERY_WEEK, CUSTOM
        :param pulumi.Input[builtins.bool] time_all_day: Rule will be running for all day. Time range start/end are ignored. Applicable to: EVERY_WEEK, CUSTOM
        :param pulumi.Input[builtins.str] time_range_end: End time in 24 hours format. It accepts 24:00 as end of the day. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        :param pulumi.Input[builtins.str] time_range_start: Start time in 24 hours format. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        pulumi.set(__self__, "mode", mode)
        if end_date_applicable_to_custom is not None:
            pulumi.set(__self__, "end_date_applicable_to_custom", end_date_applicable_to_custom)
        if start_date_applicable_to_custom is not None:
            pulumi.set(__self__, "start_date_applicable_to_custom", start_date_applicable_to_custom)
        if date is not None:
            pulumi.set(__self__, "date", date)
        if repeat_on_days is not None:
            pulumi.set(__self__, "repeat_on_days", repeat_on_days)
        if time_all_day is not None:
            pulumi.set(__self__, "time_all_day", time_all_day)
        if time_range_end is not None:
            pulumi.set(__self__, "time_range_end", time_range_end)
        if time_range_start is not None:
            pulumi.set(__self__, "time_range_start", time_range_start)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input['FirewallPolicyScheduleDtoMode']:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input['FirewallPolicyScheduleDtoMode']):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="EndDateApplicableToCUSTOM")
    def end_date_applicable_to_custom(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "end_date_applicable_to_custom")

    @end_date_applicable_to_custom.setter
    def end_date_applicable_to_custom(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_date_applicable_to_custom", value)

    @property
    @pulumi.getter(name="StartDateApplicableToCUSTOM")
    def start_date_applicable_to_custom(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "start_date_applicable_to_custom")

    @start_date_applicable_to_custom.setter
    def start_date_applicable_to_custom(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_date_applicable_to_custom", value)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start date. Applicable to: ONE_TIME_ONLY
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter(name="repeatOnDays")
    def repeat_on_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyScheduleDtoRepeatOnDaysItem']]]]:
        """
        Repeat on on days. Applicable to: EVERY_WEEK, CUSTOM
        """
        return pulumi.get(self, "repeat_on_days")

    @repeat_on_days.setter
    def repeat_on_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyScheduleDtoRepeatOnDaysItem']]]]):
        pulumi.set(self, "repeat_on_days", value)

    @property
    @pulumi.getter(name="timeAllDay")
    def time_all_day(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Rule will be running for all day. Time range start/end are ignored. Applicable to: EVERY_WEEK, CUSTOM
        """
        return pulumi.get(self, "time_all_day")

    @time_all_day.setter
    def time_all_day(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "time_all_day", value)

    @property
    @pulumi.getter(name="timeRangeEnd")
    def time_range_end(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End time in 24 hours format. It accepts 24:00 as end of the day. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        return pulumi.get(self, "time_range_end")

    @time_range_end.setter
    def time_range_end(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_range_end", value)

    @property
    @pulumi.getter(name="timeRangeStart")
    def time_range_start(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start time in 24 hours format. Applicable to: EVERY_DAY, EVERY_WEEK, ONE_TIME_ONLY, CUSTOM
        """
        return pulumi.get(self, "time_range_start")

    @time_range_start.setter
    def time_range_start(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_range_start", value)


if not MYPY:
    class FirewallQosDestinationDtoArgsDict(TypedDict):
        matching_target: pulumi.Input['FirewallQosDestinationDtoMatchingTarget']
        port_matching_type: pulumi.Input['FirewallQosDestinationDtoPortMatchingType']
        matching_target_type: NotRequired[pulumi.Input['FirewallQosDestinationDtoMatchingTargetType']]
        port: NotRequired[pulumi.Input[builtins.str]]
        port_group_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    FirewallQosDestinationDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallQosDestinationDtoArgs:
    def __init__(__self__, *,
                 matching_target: pulumi.Input['FirewallQosDestinationDtoMatchingTarget'],
                 port_matching_type: pulumi.Input['FirewallQosDestinationDtoPortMatchingType'],
                 matching_target_type: Optional[pulumi.Input['FirewallQosDestinationDtoMatchingTargetType']] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 port_group_id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "matching_target", matching_target)
        pulumi.set(__self__, "port_matching_type", port_matching_type)
        if matching_target_type is not None:
            pulumi.set(__self__, "matching_target_type", matching_target_type)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_group_id is not None:
            pulumi.set(__self__, "port_group_id", port_group_id)

    @property
    @pulumi.getter(name="matchingTarget")
    def matching_target(self) -> pulumi.Input['FirewallQosDestinationDtoMatchingTarget']:
        return pulumi.get(self, "matching_target")

    @matching_target.setter
    def matching_target(self, value: pulumi.Input['FirewallQosDestinationDtoMatchingTarget']):
        pulumi.set(self, "matching_target", value)

    @property
    @pulumi.getter(name="portMatchingType")
    def port_matching_type(self) -> pulumi.Input['FirewallQosDestinationDtoPortMatchingType']:
        return pulumi.get(self, "port_matching_type")

    @port_matching_type.setter
    def port_matching_type(self, value: pulumi.Input['FirewallQosDestinationDtoPortMatchingType']):
        pulumi.set(self, "port_matching_type", value)

    @property
    @pulumi.getter(name="matchingTargetType")
    def matching_target_type(self) -> Optional[pulumi.Input['FirewallQosDestinationDtoMatchingTargetType']]:
        return pulumi.get(self, "matching_target_type")

    @matching_target_type.setter
    def matching_target_type(self, value: Optional[pulumi.Input['FirewallQosDestinationDtoMatchingTargetType']]):
        pulumi.set(self, "matching_target_type", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="portGroupId")
    def port_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port_group_id")

    @port_group_id.setter
    def port_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_group_id", value)


if not MYPY:
    class FirewallQosSourceDtoArgsDict(TypedDict):
        matching_target: pulumi.Input['FirewallQosSourceDtoMatchingTarget']
elif False:
    FirewallQosSourceDtoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallQosSourceDtoArgs:
    def __init__(__self__, *,
                 matching_target: pulumi.Input['FirewallQosSourceDtoMatchingTarget']):
        pulumi.set(__self__, "matching_target", matching_target)

    @property
    @pulumi.getter(name="matchingTarget")
    def matching_target(self) -> pulumi.Input['FirewallQosSourceDtoMatchingTarget']:
        return pulumi.get(self, "matching_target")

    @matching_target.setter
    def matching_target(self, value: pulumi.Input['FirewallQosSourceDtoMatchingTarget']):
        pulumi.set(self, "matching_target", value)


