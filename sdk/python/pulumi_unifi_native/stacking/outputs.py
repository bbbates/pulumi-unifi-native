# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'StackingGroupDto',
    'StackingLagDto',
    'StackingLagGroupDto',
    'StackingLinkDto',
    'StackingUnitDto',
]

@pulumi.output_type
class StackingGroupDto(dict):
    def __init__(__self__, *,
                 lag_groups: Sequence['outputs.StackingLagGroupDto'],
                 links: Sequence['outputs.StackingLinkDto'],
                 units: Sequence['outputs.StackingUnitDto'],
                 id: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        pulumi.set(__self__, "lag_groups", lag_groups)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "units", units)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lagGroups")
    def lag_groups(self) -> Sequence['outputs.StackingLagGroupDto']:
        return pulumi.get(self, "lag_groups")

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.StackingLinkDto']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter
    def units(self) -> Sequence['outputs.StackingUnitDto']:
        return pulumi.get(self, "units")

    @property
    @pulumi.getter(name="Id")
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class StackingLagDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unitIndex":
            suggest = "unit_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StackingLagDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StackingLagDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StackingLagDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ports: Optional[Sequence[builtins.int]] = None,
                 unit_index: Optional[builtins.int] = None):
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if unit_index is not None:
            pulumi.set(__self__, "unit_index", unit_index)

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="unitIndex")
    def unit_index(self) -> Optional[builtins.int]:
        return pulumi.get(self, "unit_index")


@pulumi.output_type
class StackingLagGroupDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unitLags":
            suggest = "unit_lags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StackingLagGroupDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StackingLagGroupDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StackingLagGroupDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[builtins.int] = None,
                 unit_lags: Optional[Sequence['outputs.StackingLagDto']] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if unit_lags is not None:
            pulumi.set(__self__, "unit_lags", unit_lags)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="unitLags")
    def unit_lags(self) -> Optional[Sequence['outputs.StackingLagDto']]:
        return pulumi.get(self, "unit_lags")


@pulumi.output_type
class StackingLinkDto(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "leftPorts":
            suggest = "left_ports"
        elif key == "leftUnitIndex":
            suggest = "left_unit_index"
        elif key == "rightPorts":
            suggest = "right_ports"
        elif key == "rightUnitIndex":
            suggest = "right_unit_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StackingLinkDto. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StackingLinkDto.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StackingLinkDto.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 left_ports: Optional[Sequence[builtins.int]] = None,
                 left_unit_index: Optional[builtins.int] = None,
                 right_ports: Optional[Sequence[builtins.int]] = None,
                 right_unit_index: Optional[builtins.int] = None):
        if left_ports is not None:
            pulumi.set(__self__, "left_ports", left_ports)
        if left_unit_index is not None:
            pulumi.set(__self__, "left_unit_index", left_unit_index)
        if right_ports is not None:
            pulumi.set(__self__, "right_ports", right_ports)
        if right_unit_index is not None:
            pulumi.set(__self__, "right_unit_index", right_unit_index)

    @property
    @pulumi.getter(name="leftPorts")
    def left_ports(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "left_ports")

    @property
    @pulumi.getter(name="leftUnitIndex")
    def left_unit_index(self) -> Optional[builtins.int]:
        return pulumi.get(self, "left_unit_index")

    @property
    @pulumi.getter(name="rightPorts")
    def right_ports(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "right_ports")

    @property
    @pulumi.getter(name="rightUnitIndex")
    def right_unit_index(self) -> Optional[builtins.int]:
        return pulumi.get(self, "right_unit_index")


@pulumi.output_type
class StackingUnitDto(dict):
    def __init__(__self__, *,
                 role: 'StackingUnitDtoRole',
                 index: Optional[builtins.int] = None,
                 mac: Optional[builtins.str] = None):
        pulumi.set(__self__, "role", role)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)

    @property
    @pulumi.getter
    def role(self) -> 'StackingUnitDtoRole':
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def index(self) -> Optional[builtins.int]:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def mac(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mac")


