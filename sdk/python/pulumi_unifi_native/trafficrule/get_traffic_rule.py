# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'GetTrafficRuleResult',
    'AwaitableGetTrafficRuleResult',
    'get_traffic_rule',
    'get_traffic_rule_output',
]

@pulumi.output_type
class GetTrafficRuleResult:
    def __init__(__self__, id=None, traffic_direction_used_for_internet_and_local_network_targets=None, action=None, app_category_ids=None, app_ids=None, bandwidth_limit=None, description=None, domains=None, enabled=None, ip_addresses=None, ip_ranges=None, matching_target=None, network_ids=None, regions=None, schedule=None, target_devices=None):
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if traffic_direction_used_for_internet_and_local_network_targets and not isinstance(traffic_direction_used_for_internet_and_local_network_targets, str):
            raise TypeError("Expected argument 'traffic_direction_used_for_internet_and_local_network_targets' to be a str")
        pulumi.set(__self__, "traffic_direction_used_for_internet_and_local_network_targets", traffic_direction_used_for_internet_and_local_network_targets)
        if action and not isinstance(action, str):
            raise TypeError("Expected argument 'action' to be a str")
        pulumi.set(__self__, "action", action)
        if app_category_ids and not isinstance(app_category_ids, list):
            raise TypeError("Expected argument 'app_category_ids' to be a list")
        pulumi.set(__self__, "app_category_ids", app_category_ids)
        if app_ids and not isinstance(app_ids, list):
            raise TypeError("Expected argument 'app_ids' to be a list")
        pulumi.set(__self__, "app_ids", app_ids)
        if bandwidth_limit and not isinstance(bandwidth_limit, dict):
            raise TypeError("Expected argument 'bandwidth_limit' to be a dict")
        pulumi.set(__self__, "bandwidth_limit", bandwidth_limit)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if domains and not isinstance(domains, list):
            raise TypeError("Expected argument 'domains' to be a list")
        pulumi.set(__self__, "domains", domains)
        if enabled and not isinstance(enabled, bool):
            raise TypeError("Expected argument 'enabled' to be a bool")
        pulumi.set(__self__, "enabled", enabled)
        if ip_addresses and not isinstance(ip_addresses, list):
            raise TypeError("Expected argument 'ip_addresses' to be a list")
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ip_ranges and not isinstance(ip_ranges, list):
            raise TypeError("Expected argument 'ip_ranges' to be a list")
        pulumi.set(__self__, "ip_ranges", ip_ranges)
        if matching_target and not isinstance(matching_target, str):
            raise TypeError("Expected argument 'matching_target' to be a str")
        pulumi.set(__self__, "matching_target", matching_target)
        if network_ids and not isinstance(network_ids, list):
            raise TypeError("Expected argument 'network_ids' to be a list")
        pulumi.set(__self__, "network_ids", network_ids)
        if regions and not isinstance(regions, list):
            raise TypeError("Expected argument 'regions' to be a list")
        pulumi.set(__self__, "regions", regions)
        if schedule and not isinstance(schedule, dict):
            raise TypeError("Expected argument 'schedule' to be a dict")
        pulumi.set(__self__, "schedule", schedule)
        if target_devices and not isinstance(target_devices, list):
            raise TypeError("Expected argument 'target_devices' to be a list")
        pulumi.set(__self__, "target_devices", target_devices)

    @property
    @pulumi.getter(name="Id")
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="TrafficDirectionUsedForInternetAndLocalNetworkTargets")
    def traffic_direction_used_for_internet_and_local_network_targets(self) -> Optional['TrafficRuleDtoTrafficDirectionUsedForInternetAndLocalNetworkTargets']:
        return pulumi.get(self, "traffic_direction_used_for_internet_and_local_network_targets")

    @property
    @pulumi.getter
    def action(self) -> 'TrafficRuleDtoAction':
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="appCategoryIds")
    def app_category_ids(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "app_category_ids")

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "app_ids")

    @property
    @pulumi.getter(name="bandwidthLimit")
    def bandwidth_limit(self) -> Optional['outputs.TrafficRuleBandwidthLimitDto']:
        return pulumi.get(self, "bandwidth_limit")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence['outputs.TrafficDomainDto']]:
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence['outputs.TrafficIpDto']]:
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence['outputs.TrafficIpRangeDto']]:
        return pulumi.get(self, "ip_ranges")

    @property
    @pulumi.getter(name="matchingTarget")
    def matching_target(self) -> 'TrafficRuleDtoMatchingTarget':
        return pulumi.get(self, "matching_target")

    @property
    @pulumi.getter(name="networkIds")
    def network_ids(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "network_ids")

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.TrafficRuleScheduleDto']:
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="targetDevices")
    def target_devices(self) -> Sequence['outputs.TrafficTargetDeviceDto']:
        return pulumi.get(self, "target_devices")


class AwaitableGetTrafficRuleResult(GetTrafficRuleResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetTrafficRuleResult(
            id=self.id,
            traffic_direction_used_for_internet_and_local_network_targets=self.traffic_direction_used_for_internet_and_local_network_targets,
            action=self.action,
            app_category_ids=self.app_category_ids,
            app_ids=self.app_ids,
            bandwidth_limit=self.bandwidth_limit,
            description=self.description,
            domains=self.domains,
            enabled=self.enabled,
            ip_addresses=self.ip_addresses,
            ip_ranges=self.ip_ranges,
            matching_target=self.matching_target,
            network_ids=self.network_ids,
            regions=self.regions,
            schedule=self.schedule,
            target_devices=self.target_devices)


def get_traffic_rule(rule_id: Optional[builtins.str] = None,
                     site_name: Optional[builtins.str] = None,
                     opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetTrafficRuleResult:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__['ruleId'] = rule_id
    __args__['siteName'] = site_name
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('unifi-native:trafficrule:getTrafficRule', __args__, opts=opts, typ=GetTrafficRuleResult).value

    return AwaitableGetTrafficRuleResult(
        id=pulumi.get(__ret__, 'id'),
        traffic_direction_used_for_internet_and_local_network_targets=pulumi.get(__ret__, 'traffic_direction_used_for_internet_and_local_network_targets'),
        action=pulumi.get(__ret__, 'action'),
        app_category_ids=pulumi.get(__ret__, 'app_category_ids'),
        app_ids=pulumi.get(__ret__, 'app_ids'),
        bandwidth_limit=pulumi.get(__ret__, 'bandwidth_limit'),
        description=pulumi.get(__ret__, 'description'),
        domains=pulumi.get(__ret__, 'domains'),
        enabled=pulumi.get(__ret__, 'enabled'),
        ip_addresses=pulumi.get(__ret__, 'ip_addresses'),
        ip_ranges=pulumi.get(__ret__, 'ip_ranges'),
        matching_target=pulumi.get(__ret__, 'matching_target'),
        network_ids=pulumi.get(__ret__, 'network_ids'),
        regions=pulumi.get(__ret__, 'regions'),
        schedule=pulumi.get(__ret__, 'schedule'),
        target_devices=pulumi.get(__ret__, 'target_devices'))
def get_traffic_rule_output(rule_id: Optional[pulumi.Input[builtins.str]] = None,
                            site_name: Optional[pulumi.Input[builtins.str]] = None,
                            opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetTrafficRuleResult]:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__['ruleId'] = rule_id
    __args__['siteName'] = site_name
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('unifi-native:trafficrule:getTrafficRule', __args__, opts=opts, typ=GetTrafficRuleResult)
    return __ret__.apply(lambda __response__: GetTrafficRuleResult(
        id=pulumi.get(__response__, 'id'),
        traffic_direction_used_for_internet_and_local_network_targets=pulumi.get(__response__, 'traffic_direction_used_for_internet_and_local_network_targets'),
        action=pulumi.get(__response__, 'action'),
        app_category_ids=pulumi.get(__response__, 'app_category_ids'),
        app_ids=pulumi.get(__response__, 'app_ids'),
        bandwidth_limit=pulumi.get(__response__, 'bandwidth_limit'),
        description=pulumi.get(__response__, 'description'),
        domains=pulumi.get(__response__, 'domains'),
        enabled=pulumi.get(__response__, 'enabled'),
        ip_addresses=pulumi.get(__response__, 'ip_addresses'),
        ip_ranges=pulumi.get(__response__, 'ip_ranges'),
        matching_target=pulumi.get(__response__, 'matching_target'),
        network_ids=pulumi.get(__response__, 'network_ids'),
        regions=pulumi.get(__response__, 'regions'),
        schedule=pulumi.get(__response__, 'schedule'),
        target_devices=pulumi.get(__response__, 'target_devices')))
